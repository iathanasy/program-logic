package org.cd.cls.c4.d7;

/**
 * @description:
 * Child 继承了 Base ，也定义了和基类同名的静态变量 和实例变量 ，
 * 静态初始化代码块，实例初始化代码块，构造方法，重写了方法 step
 * @author: Mr.Wang
 * @create: 2019-09-01 20:04
 **/
public class Child extends Base{
    public static int s;
    private int a;
    static{
        System.out.println("Child 静态代码块，s:"+s);
        s = 10;
    }

    {
        System.out.println("Child 实例代码块，a:"+a);
        a = 10;
    }

    public Child(){
        System.out.println("Child 实例构造，a:"+a);
        a = 20;
    }

    @Override
    protected void step() {
        System.out.println("Child s:"+ s+", a:"+a);
    }

    public static void main(String[] args) {
        System.out.println("new Child()-----------");
        Child c = new Child();
        System.out.println("c.action()------------");
        c.action();

        Base b = c;
        System.out.println("\nb.action()-------------");
        //寻找要执行的实例方法的时候，都是从对象的实际类型信息开始查拢的，找不到的时候
        //再查找父类类型信息。
        b.action();//因为 b和c指向相同的对象，所以执行结果是一样的
        System.out.println("b.s----------------------:"+b.s);
        System.out.println("c.s----------------------:"+c.s);
        /**
         * 动态绑定：而动态绑定实现的机制就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查
         * 找父类。
         */

        /**
         * 类加载过程:
         * 在Java 中，所谓类的加载是指将类的相关信息加载到内存。在 Java 中，类是动态加载
         * 的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如
         * 果没有，则会加载其父类
         *
         * 1 ）一个类的信息主要包括以下部分
             * 类变量（静态变量）；
             * 类初始化代码；
             * 类方法（静态方法）； I
             * 实例变量；
             * 实例初始化代码；
             * 实例方法；
             * 父类信息引用
         * 2 ）类初始化代码包括：
             * 定义静态变量时的赋值语句；
             * 静态初始化代码块
         * 3 ）实例初始化代码包括：
             * 定义实例变量时的赋值语句
             * 实例初始化代码块；
             * 构造方法
         * 4）类加载过程包括：
             * 分配内存保存类的信息；
             * 给类变量赋默认值；
             * 加载父类；
             * 设置父子关系；
             * 执行类初始化代码
         *
         * 注意，类初始化代码，是先执行父类的，再执行子类的 不过，父类执行时，子类静态
         * 变量的值也是有的，是默认值 对于默认值，我们之前说过，数字型变量都是 0, boolean
         * 是false, char 是’＼uOOOO’，引用型变量是 null
         *
         * 内存分为校和堆，栈存放函数的局部变量，而堆存放动态分配的对象
         * 还有一个内存区，存放类的信息，这个区在 Java 中称为方法区。
         * 加载后， Java 方法区就有了一 份这个类的信息
         *
         *
         * 在类加载之后 new Child（）就是创建 Child 对象，创建对象过程包括：
         * I ）分配内存；
         * 2）对所有实例变量赋默认值；
         * 3）执行实例初始化代码
         * 分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量 实例初始化代
         * 码的执行从父类开始，再执行子类的 但在任何类执行初始化代码之前，所有实例变量都已设置完默认值
         *
         * 每个对象除了保存类的实例变量之外，还保存着实际类信息的引用
         *
         * 虚方法表：就是在类加载的时候为每个类创建一个表，记录该类的对象所有动态
         * 绑定的方法（包括父类的方法）及其地址，但一个方法只有一条记录，子类重写了父类方法
         * 后只会保留子类的
         *
         *
         *
         * 继承为什么会再破坏力昵？ 主要是因为继承可能 破坏封装 ，而封装可以说是程序计的第一原则；
         *
         * 对于子类而言 通过继承实现是没有安全保障的，因为父类修改内部实现
         * 细节，它的功能就可能会被破坏；而对于基类而言，让子类继承和重写方法 就可能丧失
         * 随意修改内部实现的自由
         *
         * 继承既强大又有破坏性，那怎么办呢？
         * 1 ）避免使用继承；
         * 2 ）正确使用继承
         * 我们先来看怎么避免继承，有三种方法
         * 口使用 final 关键宇
         * 口优先使用组合而非继承；
         * 口使用接口
         */

    }
}
